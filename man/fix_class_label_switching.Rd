% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dependentLCM.r
\name{fix_class_label_switching}
\alias{fix_class_label_switching}
\title{Identifies and fixes label swapping among classes. 
For each iteration, it relabels class to most align with the overall most common (mode) class of each observation.
Warning01: Best for homogeneous DLCMs. Potentially fine for heterogenous DLCMs (label swapping allowed, but not informed by domains here). Not appropriate for *partially* heterogeneous DLCMs.
Warning02: May not be appropriate if a single class is too small and therefore never shows up as the mode for any observation.
Warning03: Relabels warmup iterations which may be unnecessary.}
\usage{
fix_class_label_switching(
  dlcm,
  nwarmup,
  initial_target_classes = NULL,
  maxitr = 5
)
}
\arguments{
\item{dlcm}{An dependent latent class model from dependentLCM_fit().}

\item{nwarmup}{integer. Which iterations are warmup iterations?}

\item{initial_target_classes}{integer vector with one value per observation. What set of class labels should we try to mirror, initially? If blank defaults to the most common class for each observation.}

\item{maxitr}{integer. How many attempts should we make to correct label swapping?}
}
\value{
Returns an updated DLCM with corrected classes. Only modifies dlcm$mcmc[c('domains', 'classes', 'class_pi')]. Other information is not modified, including summary information (e.g. dlcm.summary()).
Information on what labels were swapped is given in output$label_swapping.
\itemize{
\item{"classes"}{= Integer vector. The most common (mode) class of each observation after relabeling. This serves as the target for relabeling (done iteratively).}
\item{"valueIsNewClassName_positionIsOldClassIndex"}{= Dataframe with one row per MCMC iteration describing what label swapping was done in that iteration (if any). Each iteration has a vector indexed by the original classes. For each old class index, we provide the new class name.}
\item{"valueIsOldClassName_positionIsNewClassIndex"}{= Dataframe with one row per MCMC iteration describing what label swapping was done in that iteration (if any). Each iteration has a vector indexed by the new classes. For each new class index, we provide the old class name.}
\item{"any_swaps"}{= Boolean. Did we do any label swapping? Same as nitrs_with_changes>0}
\item{"nitrs_attempted"}{= Integer. How many iterations did we run?}
\item{"nitrs_with_changes"}{= Integer. In how many iterations did we actually change class labels?}
}
}
\description{
Identifies and fixes label swapping among classes. 
For each iteration, it relabels class to most align with the overall most common (mode) class of each observation.
Warning01: Best for homogeneous DLCMs. Potentially fine for heterogenous DLCMs (label swapping allowed, but not informed by domains here). Not appropriate for *partially* heterogeneous DLCMs.
Warning02: May not be appropriate if a single class is too small and therefore never shows up as the mode for any observation.
Warning03: Relabels warmup iterations which may be unnecessary.
}
