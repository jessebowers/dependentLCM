# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name trouble_start
#' @title trouble_start
#' @description When troubleshooting, run this at start of all functions. Tracks progress.
#' @param function_name name of the function in question
#' @returns An ID identifying this specific execution of this specific function
#' @keywords internal
NULL

#' @name trouble_end
#' @title trouble_end
#' @description When troubleshooting, run this at end of all functions. Concludes tracking of progress
#' @param trouble_id ID identifying the executing of the current function taken from trouble_start
#' @param function_name name of the current function
#' @keywords internal
NULL

#' @name trouble_init
#' @title trouble_init
#' @description When troubleshooting, initializes globals
#' @keywords internal
NULL

#' @name trouble_list
#' @title trouble_list
#' @description Used to output troubleshooting information
#' @keywords internal
NULL

#' @name colMax
#' @title colMax
#' @description Get the max of each column column of matrix
#' @keywords internal
NULL

#' @name rDirichlet
#' @title rDirichlet
#' @description Generate random values from dirichlet distribution
#' @param deltas vector of dirichlet concentration parameters
#' @keywords internal
NULL

#' @name rCategorical
#' @title rCategorical
#' @description Generate random values from a polytomous categorical distribution
#' @param probs Vector of probabilities of each category from 0 to probs.size()-1. Should sum to 1.
#' @keywords internal
NULL

#' @name count_unique
#' @title count_unique
#' @description Count number of unique values in vector
#' @keywords internal
NULL

#' @name lbeta
#' @title lbeta
#' @description Calculate the beta function on log scale
#' Log(Beta(alphas)) = Log([product Gamma(alpha_i)] / Gamma(sum(alphas)))
#' @keywords internal
NULL

#' @name which
#' @title which
#' @description Give the (integer) indices where vector is true
#' @keywords internal
NULL

#' @name count_integers
#' @title count_integers
#' @description For each unique value of x, count the number of times that value appears
#' @keywords internal
NULL

#' @name map_get
#' @title map_get
#' @description Look up a value from a map. If no value found return default
#' @param map Map of key:value pairs
#' @param key Value you wish to look up
#' @param defaultvalue What we should return if key is missing from map
#' @keywords internal
NULL

#' @name minimum
#' @title minimum
#' @description Calculate the minimum of two values
#' @keywords internal
NULL

#' @name id2pattern
#' @title id2pattern
#' @description Convert pattern id to pattern vector
#' See other instance of id2pattern(.) for details
#' @keywords internal
NULL

#' @name insertSorted
#' @title insertSorted
#' @description Modifies x. Assumes x is sorted. Add new_value to x in correct position based on sort
#' @param x Sorted vector of numbers
#' @param new_value new number we wish to insert into x
#' @keywords internal
NULL

#' @name mmult
#' @title mmult
#' @description Multiply two matrixes
#' @keywords internal
NULL

#' @name equal_to_adjmat
#' @title equal_to_adjmat
#' @description Convert equivalence classes into a (graph theory style) adjacency matrix.
#' All elements of the same equivalence class are considered neighbors.
#' @param eqclass_vec Vector describing the equivalence classes. 
#' Each index represents a separate item and indexes with the same value are in the same equivalence class.
#' @keywords internal
NULL

#' @name helper_compare_adjmat
#' @title helper_compare_adjmat
#' @description Helper function. Returns true if (m1>0) == (m2>0) in all cells.
#' In other words returns true if both adjacency matrixes have the same connections (ignoring # of possible routes)
#' @keywords internal
NULL

#' @name adjmat_to_equal
#' @title adjmat_to_equal
#' @description Take a (graph theory) adjacency matrix and build equivalence classes.
#' Two nodes are in the same class if there is a path between them.
#' Returns vector. Each position represents a node and nodes with the same value are part of the same equivalence class.
#' Implicitally assumes that edges are bidirectional (a path in one direction leads to a path in the other)
#' @param adjmat Matrix identifying which nodes are neighbors (are linked).
#' @param maxiter Integer giving the maximum number of attempts to connect two nodes.
#' @keywords internal
NULL

#' @name product
#' @title product
#' @description Multiply all elements of x together
#' @keywords internal
NULL

#' @name powl
#' @title powl
#' @description calculate x^p power on integers
#' @keywords internal
NULL

#' @name Hyperparameter::set_hparams
#' @title Hyperparameter::set_hparams
#' @description Set hyperparameter values
#' For details see dependentLCM.r >> getStart_hparams(.)
#' @keywords internal
NULL

#' @name Hyperparameter::set_hparams
#' @title Hyperparameter::set_hparams
#' @description Set hyperparameter values
#' Same as other set_hparams but with list compatability for R
#' @param hparams_in list containing all arguments for Hyperparameter::set_hparams
#' @keywords internal
NULL

#' @name Hyperparameter::set_dataInfo
#' @title Hyperparameter::set_dataInfo
#' @description Use the raw data we are modeling to set certain hparams settings (e.g. set number of items)
#' Assumptions: That there are no empty levels especially at end
#' @keywords internal
NULL

#' @name Hyperparameter::print
#' @title Hyperparameter::print
#' @description Print Hyperparmeter (used mainly for troubleshooting)
#' @keywords internal
NULL

#' @name DomainCount::set_initial
#' @title DomainCount::set_initial
#' @description Set all (non-count) values for this domain
#' @param items_in Which items are in this domain?
#' @param hyparams Hyperparmeters
#' @param lthetas_in Log probablities of each response pattern of these items (optional)
#' @keywords internal
NULL

#' @name DomainCount::set_pattern2id_map
#' @title DomainCount::set_pattern2id_map
#' @description Create 'conversion vector' for converting (vector) response pattern to representative ID
#' See id2pattern(.) for more details
#' Side effect. Sets npatterns
#' @keywords internal
NULL

#' @name DomainCount::set_initial
#' @title DomainCount::set_initial
#' @description As other set_initial() but with list compatibilities for R
#' @param list_domain List of all arguments for set_initial()
#' @param hparams hyperparmeters
#' @keywords internal
NULL

#' @name DomainCount::reduce_items
#' @title DomainCount::reduce_items
#' @description Efficiently remove items from domain (without needing to re-calculate counts)
#' @param items_new Resulting items in your domain. Assumed(!!) to be subset of current items.
#' @keywords internal
NULL

#' @name DomainCount::drop_item
#' @title DomainCount::drop_item
#' @description Efficiently remove item from domain (without needing to re-calculate counts)
#' @param item item you wish to remove
#' @keywords internal
NULL

#' @name DomainCount::pattern2id
#' @title DomainCount::pattern2id
#' @description Convert (vector) response pattern to representative ID
#' See id2pattern(.) for more details
#' @keywords internal
NULL

#' @name DomainCount::get_ltheta
#' @title DomainCount::get_ltheta
#' @description Look up the log-probability of seeing this response pattern in this domain
#' @param xobs vector of the FULL response pattern (not just the items in this domain)
#' @keywords internal
NULL

#' @name DomainCount::id2pattern
#' @title DomainCount::id2pattern
#' @description Convert pattern ID to original response pattern
#' See utilities ::id2pattern(.) for more details
#' Differs from ::id2pattern(.) in that pattern2id_map is a cumulative compared to mapvec
#' Assumes items are in same order as pattern2id_map;
#' @keywords internal
NULL

#' @name DomainCount::countReset
#' @title DomainCount::countReset
#' @description Set counts to zero. 
#' Counts measure the number of times each pattern appears in the data.
#' @keywords internal
NULL

#' @name DomainCount::countAdd
#' @title DomainCount::countAdd
#' @description Add one observation to this domain's counts.
#' Counts measure the number of times each pattern appears in the data.
#' @param xobs One FULL response pattern (not just the items in this domain)
#' @keywords internal
NULL

#' @name DomainCount::list2domains
#' @title DomainCount::list2domains
#' @description Convert of list of list of r::domains to vector of map of cpp:domains
#' Used to convert R domains to CPP domains
#' @param list_list_domains
#' The outermost list has one slot for each class
#' Each class slot is a list containing individual domains (names/ids are ignored).
#' The lowest level is a list containing information about that individual domain
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name DomainCount::copy
#' @title DomainCount::copy
#' @description Creates a deep copy of this domain
#' @keywords internal
NULL

#' @name DomainCount::itemsid_calc
#' @title DomainCount::itemsid_calc
#' @description Convert domain.items into an integer id describing the items in this domain
#' @keywords internal
NULL

#' @name DomainCount::theta_alpha_fun
#' @title DomainCount::theta_alpha_fun
#' @description Allows for theta prior to change as domains get merged
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name DomainCount::getloglik_marginal
#' @title DomainCount::getloglik_marginal
#' @description For a given domain, we want to know the probability of observing a series of responses.
#' We calculate this probability conditioning on parameters, but marginalizing over theta (and convert to log scale)
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name DomainCount::print
#' @title DomainCount::print
#' @description Prints this domain (used mainly for troubleshooting purposes)
#' @keywords internal
NULL

#' @name BayesParameter::set_initial
#' @title BayesParameter::set_initial
#' @description Set all BayesParameter properties
#' See getStart_bayes_params(.) in dependentLCM.r for more details
#' @keywords internal
NULL

#' @name BayesParameter::set_initial
#' @title BayesParameter::set_initial
#' @description Set all BayesParameter properties
#' As other set_initial(.) but supports lists for R compatability
#' @keywords internal
NULL

#' @name BayesParameter::class_lprob
#' @title BayesParameter::class_lprob
#' @description What is the (log) probability that this response pattern was generated by this class?
#' @param xobs The response pattern we are investigation.
#' @param xclass The class this observation is (assumed to be) in
#' @keywords internal
NULL

#' @name BayesParameter::class_lprob
#' @title BayesParameter::class_lprob
#' @description What is the (log) probability that this response pattern was generated by EACH class?
#' Assumes all parameters are fixed/known.
#' @param xobs The response pattern we are investigation.
#' @keywords internal
NULL

#' @name BayesParameter::set_class_loglik
#' @title BayesParameter::set_class_loglik
#' @description For each observation what is the (log) probability of seeing its response pattern under EACH class?
#' Updates corresponding property in BayesParameter instance.
#' Assumes all parameters are fixed/known.
#' @param x Matrix of responses
#' @param reset Whether to initialize the matrix dimensions before running
#' @keywords internal
NULL

#' @name BayesParameter::domain_resetCounts
#' @title BayesParameter::domain_resetCounts
#' @description Reset the counts of all domains in given map
#' @keywords internal
NULL

#' @name BayesParameter::domain_resetCounts
#' @title BayesParameter::domain_resetCounts
#' @description Reset the counts in all of BayesParameter's domains
#' @keywords internal
NULL

#' @name BayesParameter::domain_addCount
#' @title BayesParameter::domain_addCount
#' @description Add given observation to all the counts in all provided domains
#' @param xobs the response pattern we are counting
#' @param xlcass The class of this observation. Needed because different domains correspond to different classes.
#' @param domains map of domains we wish to add this pattern to
#' @keywords internal
NULL

#' @name BayesParameter::domain_addCount
#' @title BayesParameter::domain_addCount
#' @description Add given observation to all the counts in all of this BayesParameter's domains
#' @param xobs the response pattern we are counting
#' @param xlcass The class of this observation. Needed because different domains correspond to different classes.
#' @keywords internal
NULL

#' @name BayesParameter::domain_addCounts
#' @title BayesParameter::domain_addCounts
#' @description Add given observations to counts in all of this given domains
#' @param x Matrix of the response patterns
#' @param reset_counts True if we should set all counts to zero before counting x.
#' @param domains Map of domains holding counts
#' @description Assumes the classes of x correspond to the classes in BayesParameter.
#' @keywords internal
NULL

#' @name BayesParameter::domain_addCounts
#' @title BayesParameter::domain_addCounts
#' @description Add given observations to counts in all domains in BayesParameter
#' @param x Matrix of the response patterns
#' @param reset_counts True if we should set all counts to zero before counting x.
#' @keywords internal
NULL

#' @name BayesParameter::item2domainid_calc
#' @title BayesParameter::item2domainid_calc
#' @description For each item find the id for the domain it belongs to.
#' If there are multiple class2domain, then multiple columns are provided (one for each)
#' @keywords internal
NULL

#' @name BayesParameter::domain_prior
#' @title BayesParameter::domain_prior
#' @description Before observing data/other-parameters, how likely are we to put items into these particular domains?
#' Some choices of domains may be more likely than other based on prior.
#' @keywords internal
NULL

#' @name BayesParameter::get_superdomains
#' @title BayesParameter::get_superdomains
#' @description Merge overlapping domains from different class2domainid
#' @param item2domainid Each colum describes what items must be grouped together for this item2domainid
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name BayesParameter::is_identifiable
#' @title BayesParameter::is_identifiable
#' @description Check if choice of domains is generically identifiable
#' Uses greedy algorithm. May fail in some cases, but is deterministic (if bad then consistently conservative for that choice of domains)
#' See Allman paper (DOI:10.1214/09-AOS689 Theorem 4.) for criteria used: min(patterns1,nclass)+min(patterns2,nclass)+min(patterns3,nclass) > 2*nclass+2
#' @param item2superdomainid Vector describing which items must be grouped together
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name BayesParameter::is_identifiable
#' @title BayesParameter::is_identifiable
#' @description Check if choice of domains is generically identifiable under proposal
#' @param proposal The candidate changes to domains we are evaluating
#' @param hparams hyperparameters
#' @keywords internal
NULL

#' @name BayesParameter::domain_id_new
#' @title BayesParameter::domain_id_new
#' @description Find an empty domain. Return that domain's ID
#' @keywords internal
NULL

#' @name BayesParameter::class_pi_args
#' @title BayesParameter::class_pi_args
#' @description Calculate the dirichlet parameters for the posterior of pi (pi used for classes)
#' @keywords internal
NULL

#' @name BayesParameter::class_pi_next
#' @title BayesParameter::class_pi_next
#' @description Do gibbs sampling to generate pi (pi used for classes)
#' @keywords internal
NULL

#' @name BayesParameter::classes_next
#' @title BayesParameter::classes_next
#' @description Do gibbs sampling to calculate the class of each observation
#' @keywords internal
NULL

#' @name BayesParameter::thetas_next
#' @title BayesParameter::thetas_next
#' @description Do gibbs sampling to calculate thetas for each domain
#' @keywords internal
NULL

#' @name BayesParameter::domain_proposal
#' @title BayesParameter::domain_proposal
#' @description Propose new domains in metropolis algorithm
#' Essentially we choose two domains at random and move items between them (oversimplification).
#' We take a nonempty domain. 1) With some probability we move one of its items to an empty domain. Otherwise we choose a second nonempty domain. 2) With some probability we swap a pair of items between the two nonempty domains. 3) Otherwise we move one item from the first domain into the second.
#' There are some restrictions including 1) We do not swap items if both domains are singletons (this would cause no change up to relabeling), and enforce maximum number of items per domain given in hparams.
#' @keywords internal
NULL

#' @name BayesParameter::domain_accept
#' @title BayesParameter::domain_accept
#' @description In metroplis algorithm when choosing to update domains.
#' We examine the proposal and decide whether to accept it.
#' ASSUMPTIONS domain_addCounts has been run on proposal.domains_new
#' @keywords internal
NULL

#' @name BayesParameter::domain_next
#' @title BayesParameter::domain_next
#' @description We use a metropolis algorithm to try to update domains
#' In essence we choose one item at random and either move it to another domain or swap it with an item from another domain
#' @keywords internal
NULL

#' @name BayesParameter::domains_next
#' @title BayesParameter::domains_next
#' @description Use metropolis algorithm to update domains. Repeat # of times set by hparams.
#' @keywords internal
NULL

#' @name Archive::set_initial
#' @title Archive::set_initial
#' @description Initializes the archive (namely reserving memory)
#' @keywords internal
NULL

#' @name Archive::domains2mat
#' @title Archive::domains2mat
#' @description Helper function for Archive::add
#' Used to convert the domains from map form to matrix form for storage
#' Although we could make a deep copy of the domain map each time, this would be unproductive because we need it in matrix form later for R. Therfore we convert to matrix.
#' @keywords internal
NULL

#' @name Archive::add
#' @title Archive::add
#' @description Add latest bayes parameters to the archive
#' @keywords internal
NULL

#' @name BayesContainer::set_initial
#' @title BayesContainer::set_initial
#' @description Sets all properties of BayesContainer
#' @keywords internal
NULL

#' @name BayesContainer::run
#' @title BayesContainer::run
#' @description Does #nitr MCMC steps on all bayes parameters
#' @keywords internal
NULL

#' @name BayesContainer::run_init
#' @title BayesContainer::run_init
#' @description First initializes, and then does #nitr MCMC steps on all bayes parameters
#' @keywords internal
NULL

#' @name dependentLCM_fit_cpp
#' @title dependentLCM_fit_cpp
#' @description Does MCMC simulations for dependent LCM model.
#' This is a C++ script. Run dependentLCM_fit in dependentLCM.r to execute.
#' @param x_in Matrix of responses we are analyzing
#' @param hparams_list List of hyperparameter info. See getStart_hparams() in R.
#' @param params_list List of parameter info. See getStart_bayes_params() in R.
#' @param nitr How many MCMC iterations we will run.
dependentLCM_fit_cpp <- function(x_in, hparams_list, params_list, nitr) {
    .Call(`_dependentLCM_dependentLCM_fit_cpp`, x_in, hparams_list, params_list, nitr)
}

#' @name id2pattern
#' @title id2pattern
#' @description Convert pattern id back into its original pattern vector. Then repeat each id in xpattern.
#' PatternID = Sum PatternVec[i] * [product^(i-1) mapvec[j]]
#' @param xpattern Vector of ids each representing a vector
#' @param mapvec Vector for converting id to/from vector. 
#' mapvec is of size equal to the pattern vector length.
#' mapvec values of 0 produce a PatternVec values of -1 (consider -1 to be NA).
#' @examples Suppose we have a vector of length 4 which we wish to conver to an ID (this function reverses this process).
#' Suppose the first three indexes take values 0:1 and the last takes values 0:3.
#' The appropriate mapvec in this situation would be [2,2,2,3] equal to the number of unique values in each position.
#' If we have a vector of [1,0,1,2] the corresponding id is 1*(1) + 0*(2) + 1*(2*2) + 2*(2*2*2) = 21.
#' If we have a vector id of 12 we cand find a corresponding vector of [0,0,1,1].
id2pattern <- function(xpattern, mapvec) {
    .Call(`_dependentLCM_id2pattern`, xpattern, mapvec)
}

#' @name itemid2patterns
#' @title itemid2patterns
#' @description Take pattern_id/item_id combinations and form pattern.
#' @param pattern_ids ID reprsenting the value of 'filled in' items. (unfilled items get -1)
#' @param items_ids ID reprsenting which items (positions) should be 'filled'. 
#' @param item_nlevels How many possible values each item can take
#' @examples
#' \donotrun{
#' # Find the pattern of each row in domains from IDs
#' domain_patterns <- itemid2patterns(
#'   pattern_ids = dlcm_out$mcmc$domains$pattern_id
#'   , items_ids = dlcm_out$mcmc$domains$items_id
#'   , item_nlevels = dlcm_out$hparams$item_nlevels
#'   )
#' }
itemid2patterns <- function(pattern_ids, items_ids, item_nlevels) {
    .Call(`_dependentLCM_itemid2patterns`, pattern_ids, items_ids, item_nlevels)
}

